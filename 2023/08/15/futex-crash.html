<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <title>Debugging a futex crash</title>
  <link rel="alternate" type="application/rss+xml" title="RSS" href="https://rustylife.github.io/rss.xml">
  
  <link rel="stylesheet" href="/main.min.fbee2ede33c02698d508178167c7556879b09625f70dfe0d8fa551c74788392f.css">
</head>


<h1>
  Debugging a futex crash
  <small>
    <span class="date">August 15, 2023</span>
    on
    <span class="site"><a href="https://rustylife.github.io/">Rustam Kovhaev&#39;s blog</a></span>
  </small>
</h1>

<main>
  <article>
    <p>I was enjoying my quiet afternoon, when an interesting application core has been submitted to me for research.</p>
<p>And what made it interesting is that I did not have to load proprietary/private symbols fort the application that crashed.</p>
<p>The first thing to check is whether the file is indeed a core file, and it turns out it is not.</p>
<pre tabindex="0"><code>rusty@nuc10:~/futex$ file veeamagent.0.crash 
veeamagent.0.crash: ASCII text, with very long lines (44565)

rusty@nuc10:~/futex$ head veeamagent.0.crash -n5
ProblemType: Crash
Architecture: amd64
Date: Thu Apr 27 19:26:47 2023
DistroRelease: Ubuntu 21.04
ExecutablePath: /opt/veeam/transport/VeeamAgentTmp_{24a4a58e-1080-4f6b-aa53-fd447b84ea47}/veeamagent
</code></pre><p>It is an apport report, let&rsquo;s unpack it to get the core:</p>
<pre tabindex="0"><code>rusty@ubuntu22:~$ apport-unpack veeamagent.0.crash crash

rusty@ubuntu22:~$ file crash/CoreDump 
crash/CoreDump: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from &#39;veeamagent -g2500-3300 -i{24a4a58e-1080-4f6b-aa53-fd447b84ea47}  -lflush,/var/l&#39;, real uid: 0, effective uid: 0, real gid: 0, effective gid: 0, execfn: &#39;/opt/veeam/transport/VeeamAgentTmp_{24a4a58e-1080-4f6b-aa53-fd447b84ea47}/veeamagent&#39;, platform: &#39;x86_64&#39;
</code></pre><p>CoreDump is the file we are looking for, let&rsquo;s load it in gdb.</p>
<pre tabindex="0"><code>rusty@nuc10:~/futex$ export DEBUGINFOD_URLS=&#34;https://debuginfod.ubuntu.com&#34;
rusty@nuc10:~/futex$ gdb

&gt;&gt;&gt; core-file crash/CoreDump 
Core was generated by `veeamagent -g2500-3300 -i{24a4a58e-1080-4f6b-aa53-fd447b84ea47}  -lflush,/var/l&#39;.
Program terminated with signal SIGABRT, Aborted.
#0  0x00007f7430470fbb in ?? ()
[Current thread is 1 (LWP 64283)]

&gt;&gt;&gt; bt
#0  0x00007f7430470fbb in ?? ()
#1  0x0000000000000202 in ?? ()
#2  0x0000000000000000 in ?? ()
</code></pre><p>The core is from Ubuntu 21, and, since I am opening it on my Fedora machine, I need to set up a sysroot.</p>
<p>I need to pull the system libraries either from customer&rsquo;s machine or set up an Ubuntu 21 machine in my lab.</p>
<p>I have one ready and here is what I downloaded from it:</p>
<pre tabindex="0"><code>rusty@nuc10:~/futex$ find sysroot/
sysroot/
sysroot/lib64
sysroot/lib64/ld-linux-x86-64.so.2
sysroot/lib
sysroot/lib/x86_64-linux-gnu
sysroot/lib/x86_64-linux-gnu/libc.so.6
sysroot/lib/x86_64-linux-gnu/librt.so.1
sysroot/lib/x86_64-linux-gnu/libdl.so.2
sysroot/lib/x86_64-linux-gnu/libm.so.6
sysroot/lib/x86_64-linux-gnu/libpthread.so.0
rusty@nuc10:~/futex$ 
</code></pre><p>Now, let&rsquo;s get back to gdb, set sysroot, and examine the stack again:</p>
<pre tabindex="0"><code>&gt;&gt;&gt; set sysroot /home/rusty/futex/sysroot/

&gt;&gt;&gt; i sharedlibrary 
From                To                  Syms Read   Shared Object Library
0x00007f7430dc27a0  0x00007f7430dc5d10  Yes (*)     /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/librt.so.1
0x00007f7430dba220  0x00007f7430dbb1d9  Yes (*)     /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libdl.so.2
                                        No          /opt/veeam/transport/VeeamAgentTmp_{24a4a58e-1080-4f6b-aa53-fd447b84ea47}/libblkid.so.1
                                        No          /opt/veeam/transport/VeeamAgentTmp_{24a4a58e-1080-4f6b-aa53-fd447b84ea47}/libattr.so.1
                                        No          /opt/veeam/transport/VeeamAgentTmp_{24a4a58e-1080-4f6b-aa53-fd447b84ea47}/libacl.so.1
0x00007f743064d3c0  0x00007f74306f2358  Yes (*)     /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libm.so.6
0x00007f7430623a60  0x00007f7430632334  Yes (*)     /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libpthread.so.0
0x00007f7430456650  0x00007f74305beadd  Yes (*)     /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libc.so.6
0x00007f7430dd3090  0x00007f7430df9f36  Yes (*)     /home/rusty/futex/sysroot/lib64/ld-linux-x86-64.so.2
                                        No          /opt/veeam/transport/VeeamAgentTmp_{24a4a58e-1080-4f6b-aa53-fd447b84ea47}/libuuid.so.1
(*): Shared library is missing debugging information.
&gt;&gt;&gt; 

&gt;&gt;&gt; bt
#0  0x00007f7430470fbb in raise () from /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libc.so.6
#1  0x00007f7430456864 in abort () from /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libc.so.6
#2  0x00007f74304b949c in ?? () from /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libc.so.6
#3  0x00007f74304b97b0 in __libc_fatal () from /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libc.so.6
#4  0x00007f743062f01c in __lll_lock_wait () from /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libpthread.so.0
#5  0x00007f7430627733 in pthread_mutex_lock () from /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libpthread.so.0
#6  0x0000000001acedc0 in ?? ()
#7  0x0000000000000000 in ?? ()
&gt;&gt;&gt; 
</code></pre><p>Perfect, the system libraries have loaded just fine, and, at this point, I was about to go looking for the proprietary VeeamAgent symbols, when this stack trace caught my attention.</p>
<p>Why would an attempt to lock the mutex, eventually, call abort() function?</p>
<p>Why would this simple operation in one of the threads initiate a termination of the whole process?</p>
<p>It does not make sense.</p>
<p>The only way to find out is to check glibc source code because pthread library is part of glibc.</p>
<p>__lll_lock_wait() calls futex_wait()</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>
</span></span><span class="line"><span class="cl"><span class="nf">__lll_lock_wait</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">futex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">private</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">atomic_load_relaxed</span> <span class="p">(</span><span class="n">futex</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">futex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">atomic_exchange_acquire</span> <span class="p">(</span><span class="n">futex</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nl">futex</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">lll_lock_wait</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">futex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">futex_wait</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">futex</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">private</span><span class="p">);</span> <span class="cm">/* Wait if *futex == 2.  */</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">libc_hidden_def</span> <span class="p">(</span><span class="n">__lll_lock_wait</span><span class="p">)</span>
</span></span></code></pre></div><p>futex_wait() is always inlined, that is why it is not in the stack, and futex_wait() calls futex_fatal_error(), which subsequently calls abort()</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">futex_wait</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">futex_word</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">private</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">lll_futex_timed_wait</span> <span class="p">(</span><span class="n">futex_word</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">private</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">-</span><span class="nl">EAGAIN</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">-</span><span class="nl">EINTR</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="o">-</span><span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">-</span><span class="nl">ETIMEDOUT</span><span class="p">:</span> <span class="cm">/* Cannot have happened as we provided no timeout.  */</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">-</span><span class="nl">EFAULT</span><span class="p">:</span> <span class="cm">/* Must have been caused by a glibc or application bug.  */</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">-</span><span class="nl">EINVAL</span><span class="p">:</span> <span class="cm">/* Either due to wrong alignment or due to the timeout not
</span></span></span><span class="line"><span class="cl"><span class="cm">		     being normalized.  Must have been caused by a glibc or
</span></span></span><span class="line"><span class="cl"><span class="cm">		     application bug.  */</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">-</span><span class="nl">ENOSYS</span><span class="p">:</span> <span class="cm">/* Must have been caused by a glibc bug.  */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* No other errors are documented at this time.  */</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">futex_fatal_error</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>After reading the comments, let&rsquo;s check the easiest thing first, wrong alignment.</p>
<p>Back to gdb:</p>
<pre tabindex="0"><code>&gt;&gt;&gt; frame 5
#5  0x00007f7430627733 in pthread_mutex_lock () from /home/rusty/futex/sysroot/lib/x86_64-linux-gnu/libpthread.so.0

&gt;&gt;&gt; disassemble pthread_mutex_lock
...
   0x00007f7430627723 &lt;+211&gt;:	mov    %rdi,0x8(%rsp)
   0x00007f7430627728 &lt;+216&gt;:	and    $0x80,%esi
   0x00007f743062772e &lt;+222&gt;:	call   0x7f743062efc0 &lt;__lll_lock_wait&gt;
=&gt; 0x00007f7430627733 &lt;+227&gt;:	mov    0x8(%rsp),%rdi
   0x00007f7430627738 &lt;+232&gt;:	jmp    0x7f7430627689 &lt;pthread_mutex_lock+57&gt;
...

&gt;&gt;&gt; x/w ($rsp + 8)
0x7f7371ff1ce8:	0x08001ea1
</code></pre><p>Lo and behold! The mutex address 0x08001ea1 is indeed not aligned.</p>
<p>Let&rsquo;s write a reproducer for this crash, just to confirm the hypothesis.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">pthread_mutex_t</span> <span class="n">mutex</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">&#34;.reproducer&#34;</span><span class="p">)))</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;mutex %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Now, let&rsquo;s compile it and test it, it should crash with the same stack trace as we have in our core.</p>
<pre tabindex="0"><code>rusty@nuc10:~/futex$ gcc -g futex0.c -lpthread  -Wl,--section-start=.reproducer=0x8001ea1
rusty@nuc10:~/futex$ ./a.out 
mutex 0x8001ea1
rusty@nuc10:~/futex$ 
</code></pre><p>And&hellip; It worked!</p>
<p>Why didn&rsquo;t it crash?</p>
<p>Let&rsquo;s trace that reproducer.</p>
<pre tabindex="0"><code>rusty@nuc10:~/futex$ sudo trace-cmd list -e syscalls:futex*
syscalls:sys_enter_futex
syscalls:sys_exit_futex
syscalls:sys_enter_futex_waitv
syscalls:sys_exit_futex_waitv

rusty@nuc10:~/futex$ sudo trace-cmd record -q -F -e sys_enter_fut* -e sys_exit_fut* ./a.out
mutex 0x8001ea1

rusty@nuc10:~/futex$ sudo trace-cmd report
version = 7
cpus=12
rusty@nuc10:~/futex$ 
</code></pre><p>And our reproducer did not call a single futex syscall.</p>
<p>Why? Well, it turns out that, locking an unlocked mutex is a purely user-space operation, no trip to the kernel.</p>
<p>This means that we need to modify our reproducer. The simplest way, without introducing another thread, would be to simply call pthread_mutex_lock() again. Normally this should deadlock your program, but we expect a crash just like in the original core.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">pthread_mutex_t</span> <span class="n">mutex</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">section</span><span class="p">(</span><span class="s">&#34;.reproducer&#34;</span><span class="p">)))</span> <span class="n">__attribute__</span> <span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">1</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;mutex %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Let&rsquo;s run this:</p>
<pre tabindex="0"><code>rusty@nuc10:~/futex$ gcc -g futex0.c -lpthread  -Wl,--section-start=.reproducer=0x8001ea1
rusty@nuc10:~/futex$ ./a.out 
mutex 0x8001ea1
The futex facility returned an unexpected error code.
Aborted (core dumped)
rusty@nuc10:~/futex$ 
</code></pre><p>And there we have it, the same crash as in that core.</p>
<p>Now, to put the icing on the cake, let&rsquo;s find the place in the kernel that returns that -EINVAL that causes glibc to call abort().</p>
<pre tabindex="0"><code>rusty@nuc10:~/code/kernel$ git grep -c &#34;\-EINVAL&#34; kernel/futex/
kernel/futex/core.c:1
kernel/futex/pi.c:4
kernel/futex/requeue.c:11
kernel/futex/syscalls.c:8
kernel/futex/waitwake.c:7
rusty@nuc10:~/code/kernel$ 
</code></pre><p>Quite a few places, let&rsquo;s save time and try a different approach, we have a reproducer after all.</p>
<pre tabindex="0"><code>rusty@nuc10:~/futex$ sudo trace-cmd record -q -F -p function_graph ./a.out
mutex 0x8001ea1
The futex facility returned an unexpected error code.

rusty@nuc10:~/futex$ sudo trace-cmd report
...
           a.out-867356 [004] 112365.616487: funcgraph_entry:        0.168 us   |  exit_to_user_mode_prepare();
           a.out-867356 [004] 112365.616487: funcgraph_entry:                   |  __x64_sys_futex() {
           a.out-867356 [004] 112365.616488: funcgraph_entry:                   |    do_futex() {
           a.out-867356 [004] 112365.616488: funcgraph_entry:                   |      futex_wait() {
           a.out-867356 [004] 112365.616488: funcgraph_entry:        0.150 us   |        futex_setup_timer();
           a.out-867356 [004] 112365.616488: funcgraph_entry:                   |        futex_wait_setup() {
           a.out-867356 [004] 112365.616488: funcgraph_entry:        0.199 us   |          get_futex_key();
           a.out-867356 [004] 112365.616489: funcgraph_exit:         0.425 us   |        }       
           a.out-867356 [004] 112365.616489: funcgraph_exit:         0.954 us   |      }         
           a.out-867356 [004] 112365.616489: funcgraph_exit:         1.205 us   |    }         
           a.out-867356 [004] 112365.616489: funcgraph_exit:         1.581 us   |  }
...
</code></pre><p>get_futex_key() kernel function is the main suspect according to the ftrace, let&rsquo;s check it:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">         <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">          * The futex address must be &#34;naturally&#34; aligned.
</span></span></span><span class="line"><span class="cl"><span class="cm">          */</span>
</span></span><span class="line"><span class="cl">         <span class="n">key</span><span class="o">-&gt;</span><span class="n">both</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">address</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">address</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                  <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</span></span></code></pre></div><p>And there we have it again, the futex address must be aligned.</p>
<p>And with that, we can conclude our research and send this bug report to Veeam for fixing.</p>
<p>And we did not even need private/proprietary symbols for research, but Veeam will surely need those symbols to find the place where they allocate that mutex to fix the alignment.</p>

  </article>
</main>

<footer>
</footer>

